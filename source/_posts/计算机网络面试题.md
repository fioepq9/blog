---
title: 计算机网络面试题
date: 2022-04-06 16:46:49
tags:
  - 计算机网络
categories:
  - 面试题
---

## 传输层：TCP和UDP

### 什么是三次握手？

1. 第一次握手：客户端发送一个SYN置位，序列号为随机生成的客户端初始序列号的报文给服务端，随后客户端进入SYN_SENT状态。
2. 第二次握手：服务端收到客户端的SYN报文后，根据SYN置位可知客户端在请求建立连接。然后服务端发送一个ACK置位，SYN置位，确认号为客户端初始序列号+1，序列号为随机生成的服务端初始序列号的报文给客户端。随后服务端进入SYN_RCVD状态。
3. 第三次握手：客户端检查收到的报文ACK是否置位，确认号是否为客户端初始序列号+1。客户端根据报文的SYN标志位被置位可知服务端同意建立连接，检查正确后，发送一个ACK置位，确认号为服务端初始序列号+1的报文给服务端，随后客户端进入ESTABLISHED状态。服务端收到报文后检查ACK是否置位，确认号是否为服务端初始序列号+1，检查正确后服务端也进入ESTABLISHED状态。

#### TCP建立连接可以两次握手吗？为什么？
不可以，有两个原因。
1. 第一个，是当一个因超时等原因已经失效的连接请求报文段传送到了Server。本来这是已失效的报文段，但Server会认为这是Client再次发出的新的连接请求，于是就向Client发出ACK报文段同意请求。由于是两次握手，新的连接在服务端看来已经建立了，Server会一直维持连接等待Client发送数据，白白浪费资源。
2. 第二个是，只有两次握手的话，Server无法确认Client正确接收到了第二次握手的报文，也就无法保证Client和Server之间成功交换了初始序列号。

#### 可以采用四次握手吗？为什么？

可以。但是会降低传输效率。
+ 四次握手是指：将第二次握手的报文段拆分成ACK报文和SYN报文。出于优化的目的，这是可以合并的。

#### 第三次握手中，如果客户端的ACK报文未送达服务端，会怎么样？

+ Server：由于Server没有收到ACK确认报文，因此会重发之前SYN+ACK报文（默认重发5次，之后自动关闭连接，进入CLOSED状态），Client收到SYN+ACK报文后会重发ACK报文。
+ Client端有两种情况。
  + 一种是Server超时重发过程中，Client端向服务端发送了包含ACK标志位的数据报文，服务端读取确认号后，根据确认号大于服务端初始序列号+1，可以进入ESTABLISHED状态。 
  + 另一种情况是，Server已经进入CLOSED状态了，Client向服务端发送数据，服务端会以RST包应答。

#### 如果已经建立了连接，但客户端出现了故障怎么办？

服务端每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 初始序列号是什么？(序列号的作用是什么？)

TCP是一种全双工的连接，它在两个方向都有一个初始序列号。在同一个方向上，发送端会以初始序列号作为原点，对要传输的数据进行编号。接收端通过序列号可以确认数据是否合法，同时发送端根据接收端发送的ACK报文中的确认号可以确认哪些数据已被接收。

### 什么是四次挥手？

1. 第一次挥手：Client发送一个FIN置位，并有相应序列号的报文给Server，随后进入FIN_WAIT_1状态。此时，Client不再发送数据，但仍可以接收数据。
2. 第二次挥手：Server收到FIN后，发送一个ACK置位，确认号为收到序列号+1的报文，进入CLOSE_WAIT状态。Client接收到ACK报文后，进入FIN_WAIT_2状态。
3. 第三次挥手：Server发送一个FIN置位，并填写了对应序列号的报文给Client，随后进入LAST_ACK状态。
4. 第四次挥手：Client收到服务器的FIN报文后，进入TIME_WAIT状态；接着发送一个ACK置位，确认号为三次挥手的序列号+1的报文给Server；Server接收到后，确认ACK标志位和确认号后，进入CLOSED状态。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。

#### 为什么不能把服务端发送的ACK和FIN合并，变成三次挥手？（CLOSE_WAIT状态的意义是什么？）

因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。

#### 如果第二次挥手时服务器的ACK没有送达客户端，会怎么样？

客户端没有收到ACK确认，会重新发送FIN请求。

#### 客户端TIME_WAIT状态的意义是什么？

第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2*MSL，防止Server没有收到ACK而不断重发FIN。

### TCP的流量控制是如何实现的？

TCP是使用滑动窗口协议实现流量控制的。

接收端会维护一个接收窗口，根据自身剩余缓冲区大小动态调整，在返回ACK报文时将接收窗口大小放在TCP报文首部的窗口字段中告知发送端。发送窗口的大小不能超过接收窗口的大小，只有当发送端发送的数据收到确认后，才能右移发送窗口。

发送窗口的上限为接收窗口和拥塞窗口中的较小值。接收窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。 

#### 什么是零窗口？（接收窗口为0时会怎么样？）

如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。

### TCP的拥塞控制是怎么实现的？
拥塞控制主要由四个算法组成：慢启动、拥塞避免、快速重传、快速恢复。
+ 慢启动：

在刚建立TCP连接或者出现丢包的时候，发送端处于慢启动状态，这个时候会把拥塞窗口设置为1个MSS。每接收到一个ACK报文，就增加1个MSS。这样每经过一个RTT，拥塞窗口的大小就会加倍。

+ 拥塞避免：

当拥塞窗口的大小达到慢启动阈值（ssthresh）时，开始执行拥塞避免算法。每经过1个RTT，拥塞窗口大小不再指数增长，而是线性增长。

+ 快速重传：

接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不是等到自己发送数据时捎带确认。

发送方只要一连收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

+ 快速恢复：

当发送方连续收到三个重复确认时，就把慢启动阈值减半，同时将拥塞窗口的大小置为慢启动阈值的大小，然后执行拥塞避免算法。

不执行慢开始算法的原因是：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。

### TCP如何保证可靠性？

1. TCP首部的校验和
2. 应答机制：接收端收到数据之后会根据序列号，会发送一个ACK确认报文。
3. 超时重发机制：发送端发出数据后，会启动一个定时器，超时未收到ACK报文，就会重发。
4. 流量控制：确保接收端能完整接收发送端的数据而不会缓冲区溢出。
5. 拥塞控制：当网络拥塞时，通过拥塞控制减少数据的发送，防止包丢失。

### TCP与UDP的区别

1. 连接
TCP是面向连接的传输层协议，传输数据前要先建立连接。
UDP是无连接的，直接就可以传输数据。

2. 服务对象
TCP是一对一的两点服务，即一条连接只有两个端点。
UDP支持一对一、一对多、多对一、多对多的交互通信。

3. 可靠性
TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。
UDP是尽最大努力交付数据，不保证可靠性。

4. 拥塞控制、流量控制
TCP有拥塞控制和流量控制机制，保证数据传输的安全性。
UDP则没有，即使网络非常拥堵，也不会影响UDP的发送速率。

5. 首部开销
TCP的首部较长，最小是20个字节，如果使用了额外的选项，还会进一步增长。
UDP的首部只有8个字节，并且是固定不变的，开销较小。

6. 传输方式
TCP是流式传输，没有边界，但保证顺序和可靠性。
UDP是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

7. 分片方式
TCP的数据大小如果大于MSS，则会在传输层进行分片，如果传输过程中丢失了一个分片，只需要重传这个丢失的分片。
UDP的数据大小如果大于MTU，则会在IP层进行分片。

#### 什么时候选择TCP，什么时候选择UDP？

对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下使用TCP，因为要求传输的内容可靠，不出现丢失。

#### HTTP可以使用UDP吗？

可以，HTTP/3就是基于UDP的。

## 应用层：HTTP和HTTPS

### HTTP的请求报文包含什么？

请求报文是由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成的。

![HTTP请求报文](https://raw.githubusercontent.com/ltlin9/note-img/master/img/2022/03/26/20220326-171734.png)

### HTTP的响应报文包含什么？

响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。

![HTTP响应报文](https://raw.githubusercontent.com/ltlin9/note-img/master/img/2022/03/26/20220326-171946.png)

### HTTP的报文头部和报文主体如何区别？

存在一个CR+LF组成的标准空行，进行分隔。

### HTTP和HTTPS有什么区别？
1. 知名端口不同：HTTP的知名端口是80，HTTPS是443。
2. HTTP是明文传输，HTTPS运行在SSL之上，添加了加密和认证机制，更加安全。
3. HTTPS由于需要加密和解密，对主机会有更大的CPU和内存开销，同时传输开销也更大。
4. HTTPS通信需要证书，一般要向证书颁发机构（CA）购买。

#### HTTPS的连接过程？（HTTPS的加密过程？）

##### Answer 1
1. 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；

2. 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密,用证书机构的私钥加密后的服务器公钥），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；

3. 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，证书机构的公钥能否正确解开服务器证书的“数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；

4. 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；

5. 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息摘要发给浏览器；

6. 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密。

##### Answer 2

1. 客户端发送Client Hello报文开始SSL通信。

   + Client Hello：报文中包含客户端支持的SSL的指定版本、加密组件列表（所使用的加密算法及密钥长度等）

2. 服务端如可进行SSL通信，会以Server Hello报文作为应答，随后发送Certificate、Server Key Exchange、Server Hello Done报文结束最初的SSL握手协商。

     + Server Hello：报文中包含服务端支持的SSL的指定版本、加密组件列表（所使用的加密算法及密钥长度等），其中加密组件的内容是从Client Hello中进一步筛选的。
     + Certificate：报文中包含公开密钥证书，证书里面包含了用证书机构的私钥加密后的服务端公钥，以及证书颁发机构的数字签名信息。
     + Server Key Exchange
3. 客户端发送Client Key Exchange报文，接着发送Change Cipher Spec报文，最后发送Finished报文。

     + Client Key Exchange：报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用服务端公钥进行加密。
     + Change Cipher Spec：该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
     + Finished：该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确解密该报文作为判定标准。
4. 服务端发送Change Cipher Spec报文，接着发送Finished报文。
5. 服务器和客户端的 Finished 报文交换完毕之后，SSL连接就算建立完成。当然，通信会受到 SSL的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。

#### 什么是对称加密、非对称加密？区别是什么？

+ 对称加密：加密和解密使用相同的密钥。
+ 非对称加密：有两个密钥：公钥和私钥。用公钥加密的，需要用私钥解密。用私钥加密的，需要用公钥解密。
+ 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高，原因是不需要传输私钥。

#### 数字签名的原理

证书机构用私钥进行签名，客户端用公钥验证签名。因为我们信任证书机构，且除证书机构外没有人持有该私钥，客户端的公钥嵌入在了浏览器中，所以保证了数字签名的可靠。

### GET和POST的区别？
1. GET方法是幂等的，即访问同一个资源，总是得到相同的数据。
2. 请求形式上：GET请求的参数附在URL之后，POST请求的参数在请求体中。
3. GET请求可被缓冲、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高。
4. GET只允许ASCII字符（因为URL只支持ASCII字符），POST则没有限制。
5. GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制。

### Session与Cookie的区别？

Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案。

Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Session id查看状态。保存Session id的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。

### 从输入网址到获得页面的过程？
1. 浏览器对URL进行解析，获取到使用的协议、域名、端口号、URI。这里的协议、端口号、URI都可以是缺省的，缺省状态下，协议使用http，端口号使用http的知名端口80，URI缺省情况则表示访问服务器事先设置的默认文件。
2. 浏览器根据URL解析后获得的信息生成HTTP请求信息。
3. 浏览器查询自身对域名的缓存，未命中就继续查询操作系统的缓存，如果还是未命中就查询hosts文件。最后如果没有查询到域名的对应IP地址，浏览器就会使用DNS协议进行域名解析。
  + 域名解析过程：
    1. 客户端首先向本地DNS服务器（在TCP/IP设置中填写的DNS服务器地址）发出一个DNS请求。
    2. 本地域名服务器收到请求后：如果缓存里能找到映射关系，就直接返回；如果没有，本地域名服务器会去询问根域名服务器。
    3. 根域名服务器收到请求后，返回域名对应的顶级域名服务器地址。
    4. 本地域名服务器收到顶级域名服务器地址后，会去询问顶级域名服务器。
    5. 顶级域名服务器收到请求后，返回域名对应的权威名称服务器地址。
    6. 本地域名服务器收到权威名称服务器地址后，会去询问权威名称服务器。
    7. 权威名称服务器收到请求后，就会返回域名对应的IP地址。
    8. 本地域名服务器收到IP地址后，将它进行缓存，然后返回给客户端。
4. 浏览器获取到域名对应的IP地址后，首先要跟服务器请求建立TCP连接，也就是进行TCP三次握手。三次握手的目的是保证双方都有发送和接收的能力。
5. 在TCP模块执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成网络包发送给通信对象。因为当前IP网络包上层是TCP协议，所以IP首部的协议号填写为0x06，表示上层协议为TCP。如果客户端存在多个网卡，那么就需要根据路由表规则来判断使用哪一个网卡进行发送。
  + 路由表规则：将目标地址和子网掩码进行与运算，以匹配子网，发送到第一个匹配到的子网。在路由表项末尾存在一个默认网关，所有其它所有条目都无法匹配，就会匹配到这一行，并且后续把包发给路由器。
6. 生成了IP首部以后，网络包还需要再IP首部前面加上MAC首部。MAC首部包含目的MAC地址、源MAC地址、协议类型（一般在TCP/IP中，只使用0800(IP协议)、0806(ARP协议)）。
  + 源MAC地址：直接从网卡中读取
  + 目的MAC地址：先查询ARP缓存；未命中，则如果目的IP地址与原IP地址在同一子网中，则会向子网中发送ARP广播；如果不在同一子网中，则通过ARP询问默认网关对应的MAC地址。（每次查询结果会放入本机的ARP缓存中，保存时间大概为几分钟）

1. 浏览器根据输入URL中的域名查询DNS，获取对应的IP地址：具体过程是浏览器查询自身的DNS缓存，未命中则查询操作系统的DNS缓存，未命中则向本地DNS服务器进行查询。本地DNS服务器收到请求，如果没有缓存，就向根域名服务器请求，根域名服务器会返回相应的顶级域名服务器地址；然后向顶级域名服务器请求，会返回名称服务器地址；然后向名称服务器请求，就能得到IP地址了。
2. 浏览器获得域名对应的IP地址以后，就会向服务器请求建立TCP连接，也就是发起TCP三次握手。
3. TCP连接建立完成后，浏览器向服务器发送HTTP请求。
4. 服务器接收到请求后，将处理结果及相应的视图返回给浏览器。
5. 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则继续向服务器请求这些资源。
6. 最后浏览器根据请求获取到的资源、数据渲染页面，向用户呈现一个完整的页面。

### HTTP请求的常见状态码

1. 以1开头的状态码，是信息性状态码；如 100 Continue。
2. 以2开头的状态码，是成功状态码；如200 OK、204 No Content、206 Partial Content。
3. 以3开头的状态码，是重定向状态码；如301 Moved Permanently（永久重定向）、302 Found（临时重定向）。
4. 以4开头的状态码，是客户端错误状态码；如400 Bad Request（报文语法错误）、401 Unauthorized（未认证）、403 Forbidden（被服务器拒绝）、404 Not Found（服务器未找到资源）。
5. 以5开头的状态码，是服务端错误状态码；如500 Internal Server Error（服务端内部错误）、503 Service Unavailable（服务不可用，处于维护）

## 计算机网络体系结构

![计算机网络体系结构](https://raw.githubusercontent.com/ltlin9/note-img/master/img/2022/04/01/20220401-200257.png)

### 什么是ARP协议？

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 **ARP 高速缓存**，里面有**所在的局域网**上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向**所在的局域网**发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。

如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。
