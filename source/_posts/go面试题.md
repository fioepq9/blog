---
title: go面试题
mathjax: true
date: 2022-04-06 19:07:10
tags:
  - golang
categories:
  - 面试题
---

# 内置类型

**string**、bool、数值类、struct、func、数组、**slice**、**map**、**chan**、**interface**

## string的底层实现？

底层是一个字符串指针加上一个cap。是一种不可变类型，每次更换内容，实际是更换底层指针。

## slice的特点

+ 每个 slice 都指向一个底层数组。
+ 使用`len()`计算 slice 长度的时间复杂度为 O(1)。
+ 使用`cap()`计算 slice 容量的时间复杂度为 O(1)。
+ 通过函数传递 slice 时，不会拷贝底层数组。
+ 通过`append()`向切片追加元素时可能触发扩容。

### slice的扩容机制？

1. 如果原 slice 的容量小于1024，则新 slice 的容量扩大为原来的2倍。
2. 如果原 slice 的容量大于等于1024，则新 slice 的容量扩大为原来的1.25倍。

## map什么时候会触发扩容？

满足下列两个条件之一：
+ 负载因子 > 6.5 时，即平均每个 bucket 存储键值对达到6.5个以上。
+ overflow 数量 > $2^{15}$ 时，即 overflow 的数量超过32768时。

### map的扩容机制？

#### 增量扩容(负载因子过大触发)

+ 新建一个新的 buckets，容量为原来的2倍。
+ 采用渐进式 rehash，在访问 map 时触发迁移。（每次搬运2个键值对）

#### 等量扩容(overflow数量过高触发)

+ 新建一个新的 buckets，容量跟原来一样。
+ 采用渐进式 rehash，在访问 map 时触发迁移。（每次搬运2个键值对）

### map的缩容机制？

现在没有真正的缩容机制，要想实现缩容，只能手动新建一个 map 然后将旧 map 的键值对进行转移。

## interface是什么？

interface 是一组方法签名，所有实现了该签名的类都可以赋值给这个接口类型的变量。

go 使用 interface 实现了「多态」和「泛型」。

### 多态的好处？

解耦了接口和实现类之间的关系，提高了代码的可维护性和灵活性。

### 两个相同接口类型的变量是如何进行比较的？

会同时比较内部的动态类型和动态值，只有都可比较且都相等的时候，才返回`true`。

# 语言特性

## go和c/c++的区别？

1. go 不支持隐式类型转换，c/c++ 支持。
2. go 要求统一的代码风格，并且有 gofmt 这个格式化工具。
3. go 通过标识符的首字母是否大写决定可见性，而 c/c++ 通过 private、public 等关键字。
4. go 支持多返回值，c/c++ 不支持。
5. go 支持匿名函数，c/c++ 只存在类似的 lambda 表达式。
6. go 在语言层面支持并发，c/c++ 需要调用外部库。
7. go 有自己的垃圾回收器，而c/c++ 只能手动进行垃圾回收。

## defer的规则

1. 延迟函数的参数在 defer 语句出现时就已经确定了。
2. 延迟函数执行按后进先出顺序执行，即先出现的 defer 最后执行。
3. 延迟函数可能操作使用 defer 语句的函数的具名返回值。

## go的多值返回是怎么实现的？

为了实现多值返回，go是使用栈空间来返回值的。而常见的C语言是通过寄存器来返回值的。go在调用函数的时候，会在栈中预留返回值的空位，在返回前将具体值赋值。

## for range遍历slice的过程中不断向slice进行append，会死循环吗？

不会。`for range`是go的一个语法糖，它在进入循环之前会先获取`len(slice)`，然后执行`len(slice)`次数的循环。

# 底层实现

## Golang的GC算法了解吗？

go使用的是三色标记法，属于标记清除法。

这里的三色，对应了垃圾回收过程中对象的三种状态：灰色，代表对象在标记队列中；黑色，代表对象已被标记；白色，代表对象未被标记。

在垃圾回收开始时，会将根对象标记为灰色，也就是放入标记队列中，然后会从标记队列中取出一个灰色对象，将它引用的对象加入队列中后将它自身变为黑色，直到队列为空。最终黑色对象保留，白色对象被回收。三色标记法实际就是对根对象进行一次BFS，最后没有遍历到的，即为需要回收垃圾。

### 根对象是什么？

全局变量、执行栈中的变量、寄存器中的变量。

### 没有STW会出现什么问题？

内存误回收：考虑一个已经扫描完毕的黑色对象，让它引用一个新建的白色对象。最终这个白色对象会被回收。

### 常见的垃圾回收算法

1. 引用计数法：对每个对象维护一个引用计数，当计数为0时回收该对象。
   + 优点：对象可以很快被回收，不会出现内存耗尽或达到某个阈值时才回收。
   + 缺点：不能很好地处理循环引用，而且实时维护引用计数，空间开销比较大。

2. 标记清除法：从根变量开始遍历所有引用的对象并标记，最后回收所有没有被标记的对象。
   + 优点：可以处理循环引用，并且不用实时维护引用计数，减少了空间上的开销。
   + 缺点：需要STW，即暂停程序运行。

3. 分代收集法：按照对象生命周期长短划分，生命周期长的放入老年代，而短的放入新生代，不同代有不同的回收算法和回收频率。
   + 优点：回收性能好。
   + 缺点：算法复杂。

## GMP模型

+ G：指goroutine。
+ M：工作线程，在go中被称为Machine。
+ P：处理器，是go中定义的一个概念，它包含运行go代码的必要资源。

### goroutine调度策略

+ 每个P维护一个包含G的本地队列，P周期性地从本地队列头部取出G调度到M中执行一小段时间后将上下文保存下来，然后将G放到本地队列尾部。除了本地队列以外，还有一个全局队列。每个P都会周期性地查看全局队列。如果一个P的本地队列中的G已全部执行完毕，那么会从全局队列中拿一批G放入本地队列；如果全局队列中也没有G，那么它会尝试将其它P的本地队列中的G偷取一半放入自身的本地队列。
+ 当G进入系统调用时，所属的M会释放P，P会被其它M获取（可能是空闲的M，如果没有空闲的M，那么新建一个M），原本的M由于系统调用而阻塞。

## 内存逃逸

在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从"栈"上逃逸到"堆"上的现象就成为内存逃逸。

### 逃逸策略

1. 如果对象在函数外部没有引用，则优先放到栈中。（如果需要内存过大，则放到堆中）
2. 如果对象在函数外部存在引用，则必定放到堆中。