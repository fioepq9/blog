---
title: 【高性能MySQL】- 第1章 MySQL架构与历史
date: 2022-04-25 14:40:04
tags:
  - 阅读笔记
  - MySQL
categories:
  - 数据库
  - MySQL
---

## MySQL逻辑架构

### MySQL服务器层

大多数MySQL的核心服务功能都在这一层，包括查询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。

### 存储引擎层

包含众多存储引擎。存储引擎负责MySQL中数据的存储和提取。每个存储引擎都有它的优势和劣势，服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异。

***

## 锁策略

### 表锁（table lock）

表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作（插入、删除、更新等）前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。

### 行锁（row lock）

行锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。

***

## 事务

### 事务的ACID特性

+ **原子性（atomicity）**

一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作，这就是事务的原子性。

+ **一致性（consistency）**

数据库总是从一个一致性的状态转换到另外一个一致性的状态。

+ **隔离性（isolation）**

通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。

+ **持久性（durability）**

一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。

### 隔离级别

+ **未提交读（READ UNCOMMITTED）**

在 READ UNCOMMITTED 级别，事务中的修改，即使没有提交，对其他事务也是可见的。

可能产生脏读、不可重复读、幻读。

+ **提交读（READ COMMITTED）**

这一级别中，事务中的修改，在提交之后，才对其他事务是可见的。

可能产生不可重复读、幻读。

+ **可重复读（REPEATABLE READ）**

该级别保证了在同一个事务中多次读取同样记录的结果是一致的。

可能产生幻读。

InnoDB存储引擎通过MVCC解决了幻读的问题。

+ **可串行化（SERIALIZABLE）**

这一级别通过强制事务串行执行，避免了幻读的问题。它会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

#### 脏读

脏读指的是：一个事务读取到其他事务中未提交的数据。

#### 不可重复读

不可重复读指的是：当某个事务在读取一条记录后，另外一个事务又对这条记录进行了写操作，当之前的事务再次读取该记录时，两次查询结果不一致的情况。

#### 幻读

幻读指的是：当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行的情况。

### 死锁

死锁是指，多个事务之间互相持有所需资源，并等待其它事务释放资源，导致循环等待的情况。

数据库系统实现了各种死锁检测和死锁超时机制。InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。

### 事务日志

事务日志可以帮助提高事务的效率。

#### 预写式日志（Write-Ahead Logging）

修改数据需要写两次磁盘。

存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录持久化到在硬盘上的事务日志中。

由于事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来说要快得多。

事务日志持久化后，内存中被修改的数据在后台可以慢慢地刷回到磁盘。

### MySQL中的事务

#### 自动提交（AUTOCOMMIT)

MySQL默认采用自动提交模式，如果不显式开始一个事务，那么每个查询都被当作一个事务执行提交操作。

#### 在事务中混合使用存储引擎

MySQL服务器层不管理事务，事务由下层的存储引擎实现。在同一个事务中，使用多种存储引擎是不可靠的。

#### 隐式和显式锁定

##### 隐式锁定

InnoDB 采用的是两阶段锁定协议（two-phase locking protocol）。在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 或者 ROLLBACK 的时候才会释放，并且所有的锁是在同一时刻被释放。

##### 显式锁定

InnoDB支持通过特定的语句进行显式锁定，这些语句不属于SQL规范。

### 多版本并发控制（MVCC）

可以认为 MVCC 是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。

MVCC 的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，事务看到的数据都保持一致性。

不同存储引擎的 MVCC 实现是不同的，典型的有**乐观（optimisitc）并发控制**和**悲观（pessimistic）并发控制**。

#### InnoDB 的 MVCC

InnoDB 的 MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存行的创建版本号，一个保存行的删除版本号。

每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

##### SELECT

查询到的记录的创建版本号早于当前事务版本，同时记录的删除版本号要么未定义，要么大于当前事务版本号。

##### INSERT

新插入的每一行保存当前系统版本号作为创建版本号。

##### DELETE

删除的每一行保存当前系统版本号为删除版本号。

##### UPDATE

插入一条新记录，保存当前系统版本号作为创建版本号，同时保存当前系统版本号到原记录中作为删除版本号。

***

## MySQL 的存储引擎

## MySQL 时间线

## MySQL  的开发模式

***
