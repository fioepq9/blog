<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>All Posts - fioepq9&#39;s blog</title>
        <link>https://fioepq9.cn/posts/</link>
        <description>All Posts | fioepq9&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>fioepq9@qq.com (fioepq9)</managingEditor>
            <webMaster>fioepq9@qq.com (fioepq9)</webMaster><lastBuildDate>Mon, 10 Oct 2022 23:38:11 &#43;0800</lastBuildDate><atom:link href="https://fioepq9.cn/posts/" rel="self" type="application/rss+xml" /><item>
    <title>Python常用刷题函数</title>
    <link>https://fioepq9.cn/python%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E5%87%BD%E6%95%B0/</link>
    <pubDate>Mon, 10 Oct 2022 23:38:11 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/python%E5%B8%B8%E7%94%A8%E5%88%B7%E9%A2%98%E5%87%BD%E6%95%B0/</guid>
    <description><![CDATA[输入输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # 读取一行，去除头尾空格和换行，以空格划分读取为整数，最后放入list。 slice = list(map(int, input().strip().split())) # 不断读取，直到EOF def readUntilEof(): try: while True: yield input() except: return for ipt in readUntilEof(): # do something # 格式化字符串 &#34;{:0&gt;2d}&#34;.format(1) # 以0填充，右对齐2宽度 &#34;{:0&lt;2d}&#34;.format(1) # 以0填充，左对齐2宽度 &#34;{:^10d}&#34;.format(1) # 居中10宽度 &#34;{0.value}&#34;.format(myVal) # 输出myVal的成员value &#34;{:.2f}&#34;.format(3.14159) # 保留2位小数 &#34;{:+.2f}&#34;.format(3.14159) # 带符号保留2位小数 &#34;{:b}&#34;.]]></description>
</item>
<item>
    <title>Golang面试题</title>
    <link>https://fioepq9.cn/golang%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
    <pubDate>Mon, 10 Oct 2022 23:36:41 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/golang%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
    <description><![CDATA[内置类型 string、bool、数值类、struct、func、数组、slice、map、chan、interface
string 的底层实现？ 底层是一个字符串指针加上一个 cap。是一种不可变类型，每次更换内容，实际是更换底层指针。
slice 的特点 每个 slice 都指向一个底层数组。 使用len()计算 slice 长度的时间复杂度为 O(1)。 使用cap()计算 slice 容量的时间复杂度为 O(1)。 通过函数传递 slice 时，不会拷贝底层数组。 通过append()向切片追加元素时可能触发扩容。 slice 的扩容机制？ 如果原 slice 的容量小于 1024，则新 slice 的容量扩大为原来的 2 倍。 如果原 slice 的容量大于等于 1024，则新 slice 的容量扩大为原来的 1.25 倍。 map 什么时候会触发扩容？ 满足下列两个条件之一：
负载因子 &gt; 6.5 时，即平均每个 bucket 存储键值对达到 6.5 个以上。 overflow 数量 &gt; $2^{15}$ 时，即 overflow 的数量超过 32768 时。 map 的扩容机制？ 增量扩容(负载因子过大触发) 新建一个新的 buckets，容量为原来的 2 倍。 采用渐进式 rehash，在访问 map 时触发迁移。（每次搬运 2 个键值对） 等量扩容(overflow 数量过高触发) 新建一个新的 buckets，容量跟原来一样。 采用渐进式 rehash，在访问 map 时触发迁移。（每次搬运 2 个键值对） map 的缩容机制？ 现在没有真正的缩容机制，要想实现缩容，只能手动新建一个 map 然后将旧 map 的键值对进行转移。]]></description>
</item>
<item>
    <title>计算机网络面试题</title>
    <link>https://fioepq9.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
    <pubDate>Mon, 10 Oct 2022 23:34:56 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
    <description><![CDATA[计算机网络体系结构 应用层：HTTP、HTTPS、DNS HTTP 是什么？ HTTP，即「超文本传输协议」，是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。
超文本的最关键点是什么？ 最关键的是「超链接」，它能够从一个超文本跳转到另一个超文本。
HTTP 的请求报文包含什么？ 请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段和内容实体构成的。
GET 和 POST 有什么区别？ 根据 RFC 规范，GET 的语义是从服务器获取指定的资源，POST 的语义是根据请求负荷对指定资源做出处理。 GET 请求的参数一般写在 URL 中，由于 URL 规定只能支持 ASCII 字符，所以 GET 的参数也只允许 ASCII 字符，同时浏览器一般会对 URL 的长度有限制。POST 请求的参数一般写在报文的 body 中，body 中的数据可以是任意格式的，只要客户端与服务端协商好即可，而且浏览器不对 body 大小做限制。 GET 方法是安全且幂等的，安全指的是不会修改服务器上的资源，幂等指的是多次执行相同的操作得到的结果也是相同的。POST 方法一般用于新增或提交数据，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。 可以对 GET 请求的数据做缓存，而且在浏览器中 GET 请求可以保存为书签。浏览器一般不会缓存 POST 请求，也不能将 POST 请求保存为书签。 HTTP 的响应报文包含什么？ 响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。
HTTP 常见的状态码有哪些？ 1xx类状态码属于提示信息，是协议处理中的一种中间状态，实际使用较少。
2xx类状态码表示请求成功被处理。
「200 OK」：表示一切正常。 「204 No Content」：与 200 OK 基本相同，但返回的响应报文中没有 body。 「206 Partial Content」：通常应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据是资源的一部分。 3xx类状态码表示请求的资源发生了变动，需要使用新的 URL 进行访问。]]></description>
</item>
<item>
    <title>数据结构与算法面试题</title>
    <link>https://fioepq9.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
    <pubDate>Mon, 10 Oct 2022 23:33:32 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
    <description><![CDATA[树 AVL 树 O(log2 n)的时间复杂度进行搜索、插入、删除操作。
红黑树 红黑性质： 每个结点或是红色的，或是黑色的。 根结点是黑色的。 null 结点视为黑色。 如果一个结点是红色的，则它的两个子结点都是黑色的。 对每个结点，从该结点到其后代叶结点的简单路径上，均包含相同数目的黑色结点。 【左倾红黑树】红色的结点只能是左结点。 引理 一颗有 n 个结点的红黑树的高度至多为 2log(n+1) 优点 红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，结合变色，降低了对旋转的要求，从而提高了性能。红黑树能够以 O(log2 n)的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。 时间复杂度：均为 O(log2 n) B/B+树 B/B+树是为磁盘或其他直接存取的辅助存储设备而设计的一种平衡搜索树。在降低磁盘 I/O 操作数方面要更好一些。
m 阶 B 树的特点 每个结点最多有 m-1 个键。 根结点至少有一个键，非根结点至少有 m/2 个键。 每个结点中的键升序排列，每个键的左子树中的所有键都小于它，右子树中的所有键都大于它。 所有叶子结点位于同一层，即根节点到每个叶子结点的高度相同。 每个结点都存有数据。 m 阶 B+树的特点 每个结点最多有 m-1 个键。 根结点至少有一个键，非根结点至少有 m/2 个键。 每个结点中的键升序排列，每个键的左子树中的所有键都小于它，右子树中的所有键都大于等于它。 所有叶子结点位于同一层，即根节点到每个叶子结点的高度相同。 只有叶子节点保存数据，同时所有叶子节点构成一个链表。 ]]></description>
</item>
<item>
    <title>操作系统面试题</title>
    <link>https://fioepq9.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</link>
    <pubDate>Mon, 10 Oct 2022 23:32:23 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</guid>
    <description><![CDATA[控制流 进程、线程、协程之间的区别？ 进程是一个运行中的程序实例，是 CPU 资源调度的基本单位；线程是运行在进程上下文的逻辑控制流，是程序执行的基本单位；协程是用户态的轻量级线程，是线程内部调度的基本单位。线程依赖于进程，一个进程里至少存在一个线程；协程依赖于线程，一个线程里至少存在一个协程。
进程持有的资源有：进程 ID、页表（提供了一个独立于其它进程的地址空间）、文件描述符表、代码段、数据段、环境变量、寄存器中的内容（通用寄存器、flag 寄存器、程序计数器）、内核栈、用户栈；
线程持有的资源有：线程 ID、寄存器中的内容（通用寄存器、flag 寄存器、程序计数器）、内核栈、用户栈；
协程持有的资源有：寄存器中的内容（通用寄存器、flag 寄存器、程序计数器）、用户栈。
切换开销上：进程 &gt; 线程 &gt; 协程。切换，实质上就是将当前上下文保存，然后取出新的上下文，显然持有的资源越多，切换的开销也就越大；同时，进程切换的时候还会刷新快表，导致快表缓存失效，也就导致新进程刚启动的时候运行速率较慢。进程、线程切换时都要陷入内核态，而协程不需要。进程、线程的切换由操作系统调度，而协程由用户自己调度。
通信方面上：进程间的通信主要依靠 IPC；而线程、协程间的通信，因为同一进程下的线程、协程共享内存，通信可以直接通过内存进行。
同一进程中的线程可以共享哪些数据？ 进程 ID、页表、文件描述符表、代码段、数据段、环境变量。
线程独占哪些资源？ 线程 ID、寄存器中的内容、内核栈、用户栈。
进程是如何进行切换的？ 进程的切换是由操作系统进行的。操作系统首先会触发一个系统调用，进入到内核态；在内核态中，将当前进程的上下文保存，然后通过进程调度算法从阻塞态的进程队列中取出一个进程，恢复新进程的上下文，然后退出内核态，将控制权移交给新进程。
进程的状态有哪些？ 五态模型 新建态：进程刚刚被创建，等待系统完成创建进程的所有必要信息。 就绪态：一个进程得到了除控制权以外的所需资源，一旦得到控制权就可以执行。 运行态：一个进程在运行的过程中。 阻塞态：一个进程正在等待某一事件的发生，或者说等待一个信号而暂时停止运行。 终止态：进程已结束运行，回收除进程控制块（PCB）之后的其他资源，并等待其他进程从 PCB 中收集相关信息。 进程调度策略有哪些？ 批处理系统 先来先服务(FCFS) 按照请求的顺序进行调度。这是一种非抢占式的算法，开销小，没有饥饿问题。可能会导致短作业的响应时间过长。
最短作业优先(SJF) 按估计运行时间最短的顺序进行调度。也是一种非抢占式的算法，吞吐量高。但如果一直有短作业到来，会导致长作业的饥饿。
最短剩余时间优先(SRTN) 按估计剩余运行时间的顺序进行调度，是最短作业优先的抢占式版本，吞吐量高。跟最短作业优先有一样的问题，可能导致长作业饥饿。
交互式系统 时间片轮转(Round Robin) 将所有就绪进程按 FCFS 的原则排成队列，用完时间片的进程回到队列尾部。这种算法很好地兼顾了响应时间和处理时间，但时间片的大小选择比较困难。如果时间片过小，进程切换频繁，开销太大；如果时间片太长，实时性就得不到保证。
优先级调度算法 为所有进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程得不到调度，可以随时间增加等待进程的优先级。
多级反馈队列调度算法(Multilevel Feedback Queue) 维护多个就绪进程队列，优先级递减，时间片递增。只有优先级更高的队列为空时才会调度低优先级队列中的队列。所有进程一开始都位于最高优先级队列，每次执行完一个时间片，就移动到下个队列。为了避免长作业饥饿问题，可以每隔一段时间，就重新将进程放入最高优先级队列。
进程间通信的方式（IPC）？ 管道（匿名管道、有名管道） 消息队列 共享内存 信号量 信号 套接字 讲讲你对同步和互斥的理解？ 同步：多个控制流因为合作而使得控制流的执行有一定的先后顺序。 互斥：同一时间只有一个控制流能够执行。 什么是死锁？ 多个控制流之间互相持有所需资源，并等待其它控制流释放资源，导致的循环等待的情况。
死锁产生的必要条件？ 互斥：一个资源一次只能被一个控制流持有。 占有并等待：一个控制流至少占有一个资源，并在等待另一个被其它控制流占有的资源。 非抢占：已经分配给一个控制流的资源不能被强制性抢占，只能由控制流完成任务后自行释放。 循环等待：若干控制流之间形成一种头尾相接的环形等待资源关系，该环路中的每个控制流等在等待上一个控制流所占有的资源。 死锁的处理方法？ 鸵鸟策略 直接忽略死锁。因为解决死锁的问题的代价很高，当发生死锁时不会对用户造成多大影响，或者发生死锁的概率很低时，可以采用鸵鸟策略。]]></description>
</item>
<item>
    <title>二分查找</title>
    <link>https://fioepq9.cn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link>
    <pubDate>Mon, 10 Oct 2022 23:28:00 &#43;0800</pubDate>
    <author>fioepq9</author>
    <guid>https://fioepq9.cn/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid>
    <description><![CDATA[二分查找是一种在有序序列中查找特定元素的搜索算法。优点是时间复杂度为 O(log n)，缺点是只能在有序序列中使用。
在升序数组 nums 中查找 target 的索引 搜索过程 实现代码（go） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 func Search(nums []int, target int) int { lo, hi := 0, len(nums)-1 for lo &lt;= hi { mid := (lo + hi) &gt;&gt; 1 if target &lt; nums[mid] { hi = mid - 1 } else if target &gt; nums[mid] { lo = mid + 1 } else { return mid } } return -1 } 在升序数组 nums 中查找 target 的最小索引 搜索过程 实现代码（go） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func SearchLeft(nums []int, target int) int { lo, hi := 0, len(nums)-1 for lo &lt;= hi { if nums[lo] == target { return lo } mid := (lo + hi) &gt;&gt; 1 if target &lt; nums[mid] { hi = mid - 1 } else if target &gt; nums[mid] { lo = mid + 1 } else { hi = mid } } return -1 } 在升序数组 nums 中查找 target 的最大索引 搜索过程 实现代码（go） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 func SearchRight(nums []int, target int) int { lo, hi := 0, len(nums)-1 for lo &lt;= hi { if nums[hi] == target { return hi } mid := (lo+hi)&gt;&gt;1 + (lo+hi)&amp;1 if target &lt; nums[mid] { hi = mid - 1 } else if target &gt; nums[mid] { lo = mid + 1 } else { lo = mid } } return -1 } ]]></description>
</item>
</channel>
</rss>
